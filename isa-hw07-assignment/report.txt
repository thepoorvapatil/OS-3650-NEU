# HOMEWORK 6 REPORT

## Local Machine Information
	- Operating System: Debian - 64bit 
	- Processor Model: 2,3 GHz Intel Core i5
	- Number of Processor Cores: 4
	- Amount of RAM: 2048 MB

## CCIS Server Information
	- Operating System: CentOS
	- Processor Model: Intel Xeon Gold 5118
	- Number of Processor Cores: 48
	- Amount of RAM: 190 GB. 

## Time Measurements	
			-------------------------------------------------------------------
                      	-	LOCAL MACHINE 		 -        CCIS SERVER		  -
			-------------------------------------------------------------------
			- Median Time - Parallel Speedup - Median Time - Parallel Speedup -
	 ----------------------------------------------------------------------------------
	 1 process	-    96.71s   -		1	 -    119.46s   -	1	  -
	 ----------------------------------------------------------------------------------
	 4 processes	-    92.27s   -	      1.05	 -    117.62s   -       1,02  	  -
	 ----------------------------------------------------------------------------------
	 8 processes	-    92.44s   -	      1.04	 -    116.75s    -      1,02	  -
	 ----------------------------------------------------------------------------------


## Optimal Speedup: 1,05 (4 threads in local).

## Results Discussion

	In general, in this project we can see the the sorting algorithm speeds up when we create more threads to sort the input numbers in parallel. The number of threads that can run at the same time in a particular enviorment depend on the number of available cores to execute our program. Therefore, when the program is executed in the local machine, in which we only have 4 available cores, we don't see any speed up when we execute the eprogram with 8 threads (that is because, since we dont have more than 4 cores, it has the same effect as if we were just executing it with 4 threads). However, in the server, we do see a speedup in this case because we have more than 4 cores available to execute the program. 

 
## Comparison
	Although we have been able to see speed up in both of the sorts we have written so far, the sort that was based on processes perfomerd better than the one based on threads. My bet is that this is due to the fact that the sorting program executing with threads has to create an output file and copy all the information over after sorting the data array. A possible speed up for this could be rading from the input file in a data float array and then, instead of sorting the data and then copying it over, sort it and copy it at the same time in the output file (each thread writes its sorted chunk of data in the output file using lseek, instead of writting back in data and then copying data over). 



